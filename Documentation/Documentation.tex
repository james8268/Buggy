\documentclass[8pt, a4paper]{article}
\usepackage{geometry}
\geometry{total={170mm, 257mm},left=20mm, top=20mm}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}

\begin{document}
\setlength \topmargin{-1in}
\title{\textbf{Software Engineering for Distributed and Interactive Systems.}}
\author{\textbf{James Ravenhill}}
\date{}
\maketitle

\section{Introduction} 

The main outcome at the beginning of the project was to create a simple and easy to used piece of software which allows the user to control the buggy without being too complex. Both the hardware and software have been an ongoing development based on feedback given through multiple tests, which a few friends generously took part in. The main objectives of the project are listed below but not limited to:

\begin{itemize}
	\item Reliability - Unreliable connection/data transfer is a disadvantage and creates more problems. This will be explained later in more detail.  
	\item  Multiple methods of communication - By using WiFi, Bluetooth, IR remote and PC. 
	\item Scalability - There should be no software problems while developing the increased load of sensor/capabilities of the buggy. 
	\item Maintainability - comments/documentation is clear to allow future developers to understand the project decisions as they happen. 
	\item Autonomous - The buggy has the ability to move in and out of an autonomous mode.  
\end{itemize}

In this document short snips of the main code will be used in explanations. The main raw code can be found in the submitted documents or on my $\href{https://github.com/james8268/Buggy}{Github}$ account.
 

\section{Design}
In terms of hardware design, the overall aesthetic is not very relevant. This being said, proper cable management and reducing the risk of damaging hardware was a great challenge due to the limited mounting points on the buggy. This challenge was overcome by using blue tac or Velcro to attach the hardware to the buggy without damaging the hardware in the process. 

\begin{figure}[H]
\centering
\includegraphics[height=4.0cm, width=5.0cm]{buggy_front}
\includegraphics[height=4.0cm, width=5.0cm]{Buggy_rear}
\caption{Left: Image of Buggy from the front left corner.}
\caption{Right: Image of Buggy from rear right corner.}
\end{figure} 


Below are two images of the main schematic of the buggy and a general communications diagram. 


\begin{figure}[H]
\includegraphics[height=5cm, width=7.0cm]{schematic}
\includegraphics[height=5cm, width=7.0cm]{Arch}
\caption{Left: Schematic of Buggy.}
\caption{Right: general communication graph of the Buggy}
\end{figure}

The software for the Arduino has been set up into header (.h) files and source code (.cpp) files where they are then called in the main code. There are many benefits to this such as the code is organised and tidy allowing future and current developers to debug with ease, addition of any new code can be easily integrated into the system and the code can be easily maintained. 

\begin{figure}[H]
	\includegraphics[width=17cm]{tabs}
	\caption{Tabs for Arduino mega main code.}
\end{figure}


The software for the ESP32 comprised of individual sketch files which correspond to the use of WiFi or Bluetooth and for both due to the ESP32 being dual-core. Transmission control protocol (TCP) has been used when using WiFi instead of user diagram protocol (UDP) as is it more reliable, has Flow control so will not overwhelm receiver and has congestion control. A 'handshake' is used to initiate communication and then multiple packets are sent. TCP may not be as fast as UDP but due to the project objectives, reliability is preferred. This being said TCP is slower by a very small margin so is not a large hindrance on the usability of the system. 
 
 
A distributed system is a system which coordinates is actions by communicating between components via passing messages. The example for this project are listed and explained below.

\begin{itemize}
	\item Mobile device-ESP32-Arduino maga: The mobile device communicated to the ESP32 through WiFi (TCP) or Bluetooth, the message that is received by the ESP32 in then passed onto the Arduino mega by universal asynchronous receiver/transmitter (UART). UART is not a communication protocol but is rather a physical circuit where serial data is transmitted and received. This emphasises the reliability factor as no data will be lost over the wired connection. When the Arduino receives a message/command the source code will then action this. If feedback is to then be sent back to the Mobile device it will do so in reverse process, the data will be sent to the ESP32 via UART and then be sent to the mobile device by WiFi/Bluetooth. 
	\item IR signal-Arduino: The IR LED input signal was initially received in the mini-bread board but this cause problems while testing due to high volumes of noise, it was therefore moved directly onto the Arduino mega. This therefore means that the IR remote can by used at the same time as the mobile device. The LCD used the I2C bus to print messages on the screen when temperature, humidity and water sensor readings are requested. 
	\item  PC-Arduino: The PC is connected directly to the Arduino mega and is controlled using the serial monitor. It is very useful for conducting quick simple tests, if new code is added to the software for example. 
	\item ESP32 disconnection feature: When the ESP32 disconnects from the WiFi router or Bluetooth then a signal will be sent to the Arduino mega. When this signal is recieved the buggy will stop, the LCD screen will be cleared and a red LED will light up to alert the user. 
\end{itemize} 

The interactivity between the buggy and the user (besides the obvious mobile device (WiFi/Bluetooth), PC communication and IR remote) consist of the following lower levels of interactiveness:

\begin{itemize}
	\item RFID scanner- This provides security as the RFID tag/card must be presented before any use of the buggy can take place. 
	\item Tilt sensor- This sends a message to the mobile device/PC aswell as sounding an alarm to communicate to the user that the buggy has tipped over due to complex/uneven terrain. 
	\item Disconnection LED- The red LED on the front of the buggy lights up when the WiFi/Bluetooth connection drops.  
	\item Ultrasound sensor- This interacts with its surroundings to gain distance information. This information can then be actioned on accordingly, for example while in an autonomous mode distance information will be used to make decisions and avoid obstacles. 
\end{itemize}
These may seem like simple solutions but they are effective and prove effective during testing. They also provide a level of security to the buggy, the RFID tag can only be added to the source code. 

\section{Implementation}

///talk about figures below
 
\begin{figure}[H]
	\centering
	\includegraphics[height=5.0cm, width=6.0cm]{bluetooth}
	\includegraphics[height=5.0cm, width=6.0cm]{standard_wifi}
	\caption{Left: ESP32 Bluetooth main loop code.}
	\caption{Right: ESP32 standard Wifi main loop code.}
\end{figure}

///talk about how Blynk is different but the same in principle hence still works

\begin{figure}[H]
	\centering
	\includegraphics[height=5.0cm, width=6.0cm]{blynk1}
	\includegraphics[height=5.0cm, width=6.0cm]{blynk2}
	\caption{Left: ESP32 Blynk read from the mobile device and send messages to the Arduino Mega.}
	\caption{Right: ESP32 Blynk read meaasges from arduino and send to mobile device}
\end{figure}

///Talk about multi core 

\begin{figure}[H]
	\centering
	\includegraphics[height=4.0cm, width=15.0cm]{multicore}
	\caption{Setup for ESP32 dual core WiFi and Bluetooth.}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[]{main_loop}
\includegraphics[height=4cm]{read_message}
\caption{Left: Arduino mega main loop}
\caption{Right: Read incoming message}
\end{figure}

Looking at Figure 6 you can see the main loop for the Arduino mega. The commands here are reading the serial monitor when the buggy is connected to the PC as well as the IR remote control reader and the ESP32 reader (this reads messages from the mobile device). Other commands that monitor the tilt sensor and the Wifi/Bluetooth connection are at the bottom of Figure 6. 



3rd Party libraries:
\verb|arduino.h|, \verb|LiquidCrystal_I2C.h|, \verb|IRremote.h|, \verb|Wire.h|, \verb|dht.h|, \verb|SPR.h|, \verb|MFRC522.h|


\section{Testing}
//insert images, using bluetooth, wifi, multicore. 


\section{Evaluation}

//// pros and cons of WIFI and bluetooth.
//// limitations to each distributive method.  


\section{Code quality/remarks} ////this may get cut if needed as in more an non written task
////discuss multi and single core methods in a ReadMe file!!!


///Layers- layered system to allow for easy maintenance, ease of updating/developing the system. ADD A DIAGRAM OF THE LAYERS HERE. 


\section{Demonstration}
////film the video and then refer to it for the following subsections


\subsection{Distribution}
///Define what a distributed system is 

\subsection{Interactive}
///Define what an interactive system is

\subsection{Performance}






\section{Conclusion}


\section{Reference Library and appendices}
\subsection{Github account}

\href{https://github.com/james8268/Buggy}{Click here for Github hyper link} 

or copy and paste the URL into your web browser. https://github.com/james8268/Buggy

\listoffigures

\subsection{Test Comments}
Test 1

Getting to grips with the Bluetooth, 28/10/2020: The device worked exactly how it should every command button worked as it should. The controls were very easy to understand and get to grips with which means I could use the buggy how I wanted with no issues. Only thing I would like to add is that the left and right turns be a little less aggressive. So instead of a 90 degree turn maybe a 45 instead. Also I would like the distance of the sensor to be displayed on the mobile device as well as the LCD screen on the buggy so I don’t have to be stood directly over the buggy to know this information, as I think this would make it more user friendly. Other than that, it was flawless.

Test 2

This test is like the last with a few minor changes. This time around the buggy is in a combined remote Bluetooth and autonomous mode. The autonomous element will allow the buggy to roam freely while avoiding obstacles.

Acting on the previous test a feature of being able to see the reading of the ultrasound sensor has now been added and can be viewed in the mobile device terminal as well as the turns being less harsh.

Test 2.1, using the combined autonomous and Bluetooth mode, 04/11/2020: self-roaming was effective, the buggy avoided obstacles well, although had trouble once it was under a certain distance from complex obstacles. commands were easy to pick up and the buggy was easy to manoeuvre, although lag time could be reduced, or possibly a cut off after x number of commands. possibly introduce a short cut to speed one and/or options for varying stop times, so that when flustered a driver can take time to re-think.

Test 2.2, test is the same as previous (code remains the same as the last test), 05/11/2020: the buggy avoided the obstacles well however due to lag it made it difficult to manoeuvre, also would be much easier and efficient for the driver if there was a cut off command so that the user can re-access the situation and move from there.  

Test 3

The buggy now can roam around autonomously while avoiding obstacles and this can then be stopped and be used remotely again. It’s easy to switch between the two, using the mobile device terminal the "roam" hotkey enters the buggy into an autonomous mode(which can be seen when the android device is tilted on a landscape view and the screen will show more potential hotkeys). when any button/command is used in the terminal the buggy will then exit the autonomous mode and reverts to a remote mode. 

Test 3, testing combined autonomous and remote modes, 07/11/2020: I enjoyed the new features on the handset. The fact that the buggy now had a roam feature was very interesting. The fact it could now make decisions on what was in front of it and change the course on which it was travelling due to an object being in its way was fascinating. A cool feature would be if it could decide which way it wanted to turn. For instance, left or right depending on the amount of space it has either side, this depends on the amount ultrasound sensors it has available. All the other buttons worked well and did what I wanted when I asked it to. 

Test 4

A tilt sensor and servo motor have now been added, the use of WIFI connection is also up and running. Security measures have been added so if WIFI or Bluetooth connection is lost it will stop the buggy and turn on the front red LED. The servo motor allows the buggy to look left and right and then decide on which direction to move. The tilt sensor will monitor the buggy and if it capsizes or is flipped over it will stop the buggy and turn on a buzzer as well as notifying the user if in remote mode. 

tests to be completed:
\begin{itemize}
\item turning system for servo ultrasound sensor, just to check its working right.
\item tilt sensor while in autonomous mode while moving. 
\item temp and humidity sensor and water sensor while moving and stationary. 
\item disconnect functions via Bluetooth, by trying to connect another device (already known that two devices can’t connect over Bluetooth).
\item disconnect from WiFi, turn off router. 
\item test overall usability.
\end{itemize}

Test 4, 23/11/2020, testing the new obstacle avoidance system, tilt sensor and the temp, humidity and water sensor (all in Bluetooth mode): I found the new obstacle avoidance system was very good the Buggy made very accurate adjustments when it came to an obstruction. the fact it was able to stop look around and decide for itself which way to go was very impressive. the tilt sensor that has been integrated into the buggy was a very impressive feature. especially since you had the use of this both in autonomous mode and just when controlling the buggy, yourself. also having the bonus of a water, temp and humidity sensor on it was very good. being able to see those readings was a nice feature to have the use of. I also found the use of the IR remote to be far more simplistic and easier to use than the Bluetooth device I much preferred it. there was a few points I feel could do with some improvement. for instance, when you are on the move and then ask the buggy to perform a water reading it stops does this command but then waits for another new instructions. I would like it to instantly carry on with the previous command once the reading has been carried out with no need to give it further instruction from either the Bluetooth device or IR remote. other than that, the buggy was very good.

Test 5

A RFID security tag has been added for security. 

Test 5, first time using WIFI set up and looking at disconnection issues. To then compare the WIFI and Bluetooth usability, 11/12/20: 

Using BLYNK: was detailed and easy to use. Very easy to read the screen. All commands worked straight away. Liked the safety feature as well the fact you had to use a key fob to be able to use the buggy. Also, the fact it tells you on the buggy with a red led that it is disconnected from the internet and you no longer have control of the buggy. 

Standard WIFI:  wasn’t as easy to use. Didn’t like the fact every time you placed a command the keyboard went away so you had to click on the box again to load a command. When I asked for a temp reading it wasn’t displayed on the WIFI app. Just gave me a random number. Also, when disconnected from the internet the red led light didn’t show on the buggy to indicate it was inoperable, however it did show on the WIFI app that it had been disconnected from the network.  

Comparison to Bluetooth: WIFI was good but the Bluetooth was far better in my opinion as I can used the buggy anywhere at any time I like with ease. Whereas with the WIFI you must have that connected to be able to use the buggy. Also, the Bluetooth has the hot keys which made the whole experience of using the buggy more user friendly and easier. 



\end{document}